<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on TianShangXing&#39;s Blog</title>
    <link>https://tianshangxing.github.io/blog/blogs/</link>
    <description>Recent content in Blogs on TianShangXing&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-hans</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Wed, 03 Jun 2020 19:54:48 +0800</lastBuildDate>
    
	<atom:link href="https://tianshangxing.github.io/blog/blogs/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MySQL进阶</title>
      <link>https://tianshangxing.github.io/blog/blogs/mysql%E8%BF%9B%E9%98%B6/</link>
      <pubDate>Wed, 03 Jun 2020 19:54:48 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/mysql%E8%BF%9B%E9%98%B6/</guid>
      <description>MySQL  MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。
官网： https://www.mysql.com/cn/
 MySQL查询  查询所有字段
select * from 表名; 例： select * from students; 查询指定字段
select 列1,列2,... from 表名; 例: select name from students; 使用 as 给字段起别名
select id as 序号, name as 名字, gender as 性别 from students; 例: -- 如果是单表查询 可以省略表名 select id, name, gender from students; -- 表名.字段名 select students.id,students.name,students.gender from students; -- 可以通过 as 给表起别名 select s.</description>
    </item>
    
    <item>
      <title>MySQL基础</title>
      <link>https://tianshangxing.github.io/blog/blogs/mysql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 02 Jun 2020 22:11:14 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/mysql%E5%9F%BA%E7%A1%80/</guid>
      <description>MySQL  MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。
官网： https://www.mysql.com/cn/
 MySQL数据类型 MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。
 数值类型 MySQL支持所有标准SQL数值数据类型。
这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。
关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。
BIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。
作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。
下面的表显示了需要的每个整数类型的存储和范围。
 日期和时间类型 表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。
每个时间类型有一个有效值范围和一个&amp;quot;零&amp;quot;值，当指定不合法的MySQL不能表示的值时使用&amp;quot;零&amp;quot;值。
 字符串类型 字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。
注意：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。
CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。
BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。
BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。
有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</description>
    </item>
    
    <item>
      <title>缺陷报告和测试管理工具</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%92%8C%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 01 Jun 2020 20:59:03 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E7%BC%BA%E9%99%B7%E6%8A%A5%E5%91%8A%E5%92%8C%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</guid>
      <description>缺陷报告编写 缺陷严重程度划分：系统崩溃，严重，一般，次要，建议
修正优先级：高，中，低
Bug定级示例 1级，系统崩溃
定义：严重阻碍测试和开发工作 对应优先级：最高 具体可分为：
 功能完全没有实现 应用闪退/崩溃无法运行 应用必现安全模式，无法运行 其他导致功能无法测试的问题  2级，至关重要
定义：非阻碍用例执行的严重问题
对应优先级：高
具体可分为：
 简单操作应用闪退/崩溃，卡死 数据丢失 严重影响系统，自身功能无法运行 严重数值计算错误 数据库损坏或无法保存配置 安全性问题（包括数据加密等）  3级，主要
定义：功能存在缺陷，但不影响应用和系统的稳定性
对应优先级：中
具体可分为：
 内存泄露（长时间不用的对象需要被回收，不被回收占内存） 功能实现逻辑覆盖不全面 非必现，但复现概率超过50%的闪退/崩溃和安全模式  4级，一般
定义：对应用熟悉度高才能感知到的问题，对应用基本功能实现无影响
对应优先级：中
具体可分为：
 轻微数值计算错误 功能实现有误，与产品文档不完全贴切 用户简单操作，即可明显感知的UI问题  5级，较小
定义：界面，性能缺陷 对应优先级：低
具体可分为：
 操作界面错误（提示显示规则，刷新规则是否与文档一致） 边界条件显示错误 提示信息和界面效果展示错误（包括未给出信息、信息提示错误等） 复现率低于5%的闪退/崩溃和安全模式 插件兼容和性能未优化问题 非正常操作导致UI显示异常  6级，建议
定义：对于产品的意见或者建议 对应优先级：低
具体可分为：
 对于产品设计方面的意见和建议 对于产品界面优化方面的意见和建议 对于产品需要优化增强用户体验方面的意见和建议  Bug生命周期 新建	确认	解决	重新验证	关闭	重新打开</description>
    </item>
    
    <item>
      <title>用户后台管理测试用例</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E7%94%A8%E6%88%B7%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <pubDate>Sun, 31 May 2020 00:10:30 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E7%94%A8%E6%88%B7%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>测试用例</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</link>
      <pubDate>Fri, 29 May 2020 23:06:14 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</guid>
      <description>测试计划  需求 提取测试点 编写测试用例  测试用例 测试用例的定义：
执行测试的依据，将测试的操作步骤进行以文档的方式记录下来
测试用例的格式：
测试用例的模块	测试用例的编号	执行条件	测试输入	预期结果	实际结果
测试用例的模块：操作软件的一个大的菜单	命名以模块名称为主
测试用例的编号：命名以菜单下具体功能_数字
执行条件：操作的先决条件
测试输入：对具体的功能操作步骤
预期结果：以需求文档上的内容为主
实际结果：依据测试数据的内容输出后得到的结果可能与预期一致或者不一致
​
测试用例的特性：
代表性：能够代表并覆盖各种合理的和不合理、合法的和不合法的、边界的和越界的以及极限的输入数据、操作等。
针对性：对程序中的可能存在的错误有针对性地测试
可判定性：测试执行结果的正确性是可判定的，每一个测试用例都应有相应的期望结果
可重现性：对同样的测试用例，系统的执行结果应当是相同的
测试用例的输入类型：
 字母 数字 特殊符号 空字符 汉字  软件分类
OA：办公自动化
crm：客户管理系统
ERP：进销存系统
编写测试用例的时候3步骤走：
 根据需求提取测试用例的测试点 根据测试点内容输入不同数据类型 得到不用结果来编写测试用例  测试方法(测试策略)  等价类划分法 边界值法 因果图法 正交法 场景法 错误推断法  测试评审的标准  测试用例的正确性测试用例不含有争议 测试用例是否冗余 测试用例的覆盖率 测试用例是否满足需求文档  评审的内容有以下几个方面
 用例设计的结构安排是否清晰、合理，是否利于高效对需求进行覆盖。 优先极安排是否合理。 是否覆盖测试需求上的所有功能点。 用例是否具有很好可执行性。例如用例的前提条件、执行步骤、输入数据和期待结果是否清晰、正确_期待结果是否有明显的验证方法。 是否已经删除了冗余的用例。 是否包含充分的负面测试用例。充分的定义，如果在这里使用2&amp;amp;8法则，那就是4倍于正面用例的数量，毕竟一个健壮的软件，其中80%的代码都是在&amp;quot;保护&amp;quot;20%的功能实现。 是否从用户层面来设计用户使用场景和使用流程的测试用例。 是否简洁，复用性强。例如，可将重复度高的步骤或过程抽取出来定义为一些可复用标准步骤  </description>
    </item>
    
    <item>
      <title>测试基础</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 28 May 2020 22:38:31 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</guid>
      <description>软件开发的生命周期   客户提出需求(概念)
  根据客户的需求写出相对应的需求文档
  前端设计效果图(原型图)
后台开发人员设计与编写代码实现功能
测试人员根据需求文档编写测试计划和测试用例
  在后台开发实现功能后根据测试用例测试人员进行测试
  开发完全结束后，测试人员进行整体测试，全面测试，测试成功后进入上线
  软件上线后根据用户体验和实际效果进行小版本迭代
  软件缺陷产生的原因种类  需求变更次数频繁 理解误差 产品或者客户 开发和设计 代码问题 开发人员 运维 资源使用率产生 公司问题  测试流程  在立项会上根据客户需求编写需求文档/规格说明书，UI设计原型图后台编码，测试人员编写测试计划和测试用例 随着开发的代码实现，测试进行测试评审 主要代码实现后测试人员先进行冒烟测试 代码实现后测试执行测试用例 根据执行的结果进行对应bug提交给相对于的开发人员让其修改代码 开发修改后测试人员进行回归测试  冒烟测试：在这个软件中主要功能实现后进行测试
回归测试：在开发人员修改后进行的同一个问题的测试
软件测试的分类   按阶段划分
  单元测试：对一个模块测试
  集成测试：对多个模块测试(有一定的关联)
  系统测试：在软件编译后执行的整体测试
  验收测试：对软件执行后的用户体验的测试
​	α 阿尔法测试：有一定的开发测试人员的测试 内测
​	β 贝塔测试： 只有用户参与的测试 公测</description>
    </item>
    
    <item>
      <title>代码实现验证码功能</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Wed, 29 Apr 2020 21:44:36 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/</guid>
      <description>现在大部分网址登录时都需要输验证码才允许登录，在这里我用python代码来实现手写一套验证码逻辑
Django后端代码 # 导入图片库 # 绘画库 from PIL import ImageDraw # 字体库 from PIL import ImageFont # 图片库 from PIL import Image # 随机库 import random # 文件流 import io # 自定义图片验证码 class MyCode(View): # 定义RGB随机颜色 def get_random_color(self): R = random.randrange(255) G = random.randrange(255) B = random.randrange(255) return(R, G, B) # 定义图片视图 def get(self, request): # 画布 img_size = (130, 60) # 定义图片对象 image = Image.new(&#39;RGB&#39;, img_size, &#39;#FFFFE0&#39;) # 定义画笔 draw = ImageDraw.</description>
    </item>
    
    <item>
      <title>百度智能云文字识别</title>
      <link>https://tianshangxing.github.io/blog/blogs/%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</link>
      <pubDate>Tue, 28 Apr 2020 16:11:20 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB/</guid>
      <description>现在好多的网址在登录时都需要输入验证码才能够登录成功，防止被恶意登录
今天我就教你们一招用百度智能云来帮助我们破解验证码
首先，先申请百度智能云： https://cloud.baidu.com/
然后在人工智能 -&amp;gt; 文字识别模块 新建一个应用
建立成功后，会分配给你一个key和secret
只不过这个接口免费版的每秒最多只能请求两次，一天有500次的请求机会
这里推荐使用高精度的接口，普通的识别率太差了
在帮助文档里找到 通用文字识别（高精度版）
第一步，获取access_token
# 获取token res = requests.get(&amp;quot;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;amp;client_id=你的key&amp;amp;client_secret=你的秘钥&amp;quot;) res = json.loads(str(res.text)) token = res[&#39;access_token&#39;] 然后请求高精度识别接口，需要注意一点，这里图片需要转换成base64编码
# 接口地址 url = &#39;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic?access_token=&#39; + token # 定义头部信息 myheaders = {&#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;} # 操作图片 myimg = open(&#39;./code.png&#39;, &#39;rb&#39;) # 读取图片 temp_img = myimg.read() myimg.close() # 进行base64编码 temp_data = {&#39;image&#39;:base64.b64encode(temp_img)} # 对图片地址进行urlencode操作 temp_data = urllib.parse.urlencode(temp_data) # 请求视图接口 res = requests.post(url=url, data=temp_data, headers=myheaders) code = res.</description>
    </item>
    
    <item>
      <title>MD5加密</title>
      <link>https://tianshangxing.github.io/blog/blogs/md5%E5%8A%A0%E5%AF%86/</link>
      <pubDate>Thu, 23 Apr 2020 22:35:48 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/md5%E5%8A%A0%E5%AF%86/</guid>
      <description>MD5加密算法  代码实现
# 导入加密库 import hashlib # md5加密方法 def make_password(mypass): # 生成md5对象 md5 = hashlib.md5() # 转码操作 mypass_utf8 = str(mypass).encode(encoding=&amp;quot;utf-8&amp;quot;) # 加密操作 md5.update(mypass_utf8) # 返回密文 return md5.hexdigest() </description>
    </item>
    
    <item>
      <title>HeyUI</title>
      <link>https://tianshangxing.github.io/blog/blogs/heyui/</link>
      <pubDate>Thu, 23 Apr 2020 22:10:39 +0800</pubDate>
      
      <guid>https://tianshangxing.github.io/blog/blogs/heyui/</guid>
      <description>HeyUI  HeyUI 是一套基于 Vue2.0 的开源 UI 组件库，主要服务于一些中后台产品。
HeyUI 是一个自动化图形化界面组件，便于后端研发入手前端。
HeyUI 提供的是一整套解决方案，所有的组件提供全局的可配置模式
官网： https://www.heyui.top/
安装 npm install heyui --save
使用 import HeyUI from &#39;heyui&#39;; Vue.use(HeyUI); new Vue({ el: &#39;#app&#39;, router, components: { App }, template: &#39;&amp;lt;App/&amp;gt;&#39;, render: h =&amp;gt; h(App) }) </description>
    </item>
    
  </channel>
</rss>